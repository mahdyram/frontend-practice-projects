### **۱. مفهوم `useCallback` در React**

`useCallback` یک **Hook** است که برای بهینه‌سازی عملکرد کامپوننت‌ها استفاده می‌شود و وظیفه‌اش این است که یک **نسخه‌ی ثابت (memoized)** از یک تابع برگرداند تا در هر رندر جدید، **تابع از نو ساخته نشود** مگر اینکه وابستگی‌هایش تغییر کنند.

---

### **۲. مشکل بدون استفاده از `useCallback`**

در React، وقتی یک کامپوننت رندر می‌شود:

- تمام فانکشن‌های تعریف‌شده درون آن کامپوننت دوباره ساخته می‌شوند.
- اگر این فانکشن‌ها به عنوان **prop** به یک کامپوننت فرزند پاس داده شوند، حتی اگر کد داخل‌شان تغییر نکرده باشد، **فرزند دوباره رندر می‌شود** چون آدرس مرجع تابع تغییر کرده است.

---

### **۳. استفاده از `useCallback`**

```jsx
import { useState, useCallback } from "react";
import Child from "./Child";

export default function Counter() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const increment = useCallback(() => {
    setCount((c) => c + 1);
  }, []);

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <Child onIncrement={increment} />
      <h3>Count: {count}</h3>
    </div>
  );
}
```

اینجا:

- `increment` فقط زمانی ساخته می‌شود که آرایه وابستگی (در اینجا `[]`) تغییر کند.
- اگر از `useCallback` استفاده نمی‌کردیم، هر بار که `text` تغییر می‌کرد، تابع جدید ساخته می‌شد و باعث رندر غیرضروری `Child` می‌شد.

---

### **۴. تفاوت `useCallback` و `useMemo`**

- `useMemo` برای **ذخیره‌ی مقدار (نتیجه محاسبات)** استفاده می‌شود.
- `useCallback` برای **ذخیره‌ی یک تابع** استفاده می‌شود.

---

### **۵. چرا نمی‌توانیم تابع را در یک متغیر معمولی یا State قرار دهیم؟**

- متغیر معمولی در هر رندر دوباره تعریف می‌شود و همچنان آدرس جدید می‌گیرد.
- State برای نگهداری داده است نه خود تابع. ضمن اینکه هر بار که State تغییر کند خودش باعث رندر مجدد می‌شود و مشکل حل نمی‌شود.

---

### **۶. نقش `memo` در کنار `useCallback`**

- `memo` کامپوننت فرزند را فقط وقتی رندر می‌کند که **props تغییر کند**.
- `useCallback` باعث می‌شود **آدرس تابع** ثابت بماند و تغییر نکند.
- ترکیب این دو باعث می‌شود رندر غیرضروری از بین برود.

---

می‌تونیم `Child` رو به این شکل بنویسیم:

```jsx
import { memo } from "react";

function Child({ onIncrement }) {
  console.log("Child rendered");

  return (
    <div>
      <button onClick={onIncrement}>Increment from Child</button>
    </div>
  );
}

export default memo(Child);
```

### توضیحات:

- `memo` باعث میشه `Child` فقط زمانی رندر بشه که `onIncrement` تغییر کنه.
- بدون `useCallback` در والد، تابع در هر رندر جدید ساخته می‌شد و باعث رندر دوباره‌ی `Child` می‌شد.
- حالا با `useCallback` و `memo`، `Child` فقط زمانی رندر می‌شود که واقعاً `onIncrement` تغییر کند.

---

---

```jsx
import { memo } from "react";

function Person({ person }) {
  console.log("person rendered");

  return (
    <p>
      {person.fName} {person.lName} -
      <span className="phone">{person.phone}</span>
    </p>
  );
}

export default memo(Person);

--------

import { useMemo, useState } from "react";
import Person from "./Person";

export default function PersonForm() {
  const [count, setCount] = useState(0);
  const [phone, setPhone] = useState("");

  const person = useMemo(
    () => ({ fName: "ali", lName: "ram", phone }),
    [phone]
  );

  function resetPhone() {
    setPhone("");
  }

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <hr className="hr2" />

      <input
        type="text"
        value={phone}
        onChange={(e) => setPhone(e.target.value)}
      />
      <Person person={person} resetPhone={resetPhone} />
    </div>
  );
}
```

چرا تا فانکشن رو ازاف کردم با اینکه تو child استفاده نکردم , ولی داره rndr الکی با count پیش میاد برای چیلد ؟

علت این است که:

- **کامپوننت `Person` با `memo` پیچیده شده** و قرار است فقط زمانی رندر شود که props تغییر کنند.
- ولی وقتی `resetPhone` را در props اضافه می‌کنی، در هر بار رندر والد (`PersonForm`) یک **تابع جدید** ساخته می‌شود.

### چرا؟

- در جاوااسکریپت، هر بار که تابعی داخل کامپوننت تعریف می‌شود، یک reference جدید ساخته می‌شود:

  ```js
  function resetPhone() {
    setPhone("");
  }
  ```

  این تابع در هر رندر جدید **یک شیء جدید در حافظه است** حتی اگر بدنه‌اش تغییر نکرده باشد.

- پس `memo` می‌بیند که props تغییر کرده‌اند (به‌خاطر `resetPhone` جدید) و دوباره `Person` را رندر می‌کند.

### راه‌حل

با `useCallback` می‌توانیم reference ثابت تولید کنیم:

```jsx
const resetPhone = useCallback(() => setPhone(""), []);
```

حالا تا وقتی وابستگی‌ها تغییر نکنند، `resetPhone` همان reference قبلی می‌ماند و `Person` بی‌دلیل رندر نمی‌شود.

---

---

### جدول مقایسه `memo`, `useMemo` و `useCallback` در React

| Hook / API        | کاربرد اصلی                                                                     | چه چیزی را بهینه می‌کند؟                     | چگونه کار می‌کند؟                                                                                                   | سناریوی استفاده                                                                                                         | نکات مهم                                                                                               |
| ----------------- | ------------------------------------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| **`memo`**        | پیچیدن کامپوننت فرزند برای جلوگیری از رندرهای غیرضروری                          | **خود کامپوننت** (Child Component Rendering) | کامپوننت فقط زمانی رندر می‌شود که props آن تغییر کند (مقایسه سطحی انجام می‌دهد)                                     | وقتی کامپوننتی پیچیده دارید که propsهایش اغلب تغییر نمی‌کنند                                                            | مقایسه سطحی است؛ برای آبجکت‌ها و توابع نیاز به `useMemo` و `useCallback` دارید تا reference تغییر نکند |
| **`useMemo`**     | ذخیره‌سازی نتیجه‌ی یک محاسبه گران یا تولید یک reference پایدار برای آبجکت/آرایه | **مقدار (value)**                            | نتیجه‌ی یک تابع فقط وقتی محاسبه می‌شود که وابستگی‌ها تغییر کنند؛ در غیر این صورت مقدار کش شده بازگردانده می‌شود     | 1) محاسبات سنگین (expensive calculation) <br> 2) ساخت آبجکت یا آرایه‌ای که به عنوان prop به کامپوننت فرزند ارسال می‌شود | همیشه به ازای هر تغییر وابستگی، مقدار دوباره محاسبه می‌شود                                             |
| **`useCallback`** | برگرداندن یک reference ثابت از یک تابع                                          | **Reference توابع**                          | تنها زمانی یک تابع جدید ساخته می‌شود که وابستگی‌ها تغییر کنند؛ در غیر این صورت همان reference قبلی برگردانده می‌شود | وقتی تابعی را به کامپوننت فرزند می‌دهید که با `memo` پیچیده شده و نمی‌خواهید در هر رندر جدید باشد                       | از نظر داخلی مثل `useMemo(() => fn, deps)` است ولی مخصوص توابع                                         |

---

### چرا نمی‌توان فقط از متغیر معمولی یا state برای ذخیره `person` استفاده کرد؟

- **متغیر معمولی**: در هر رندر کامپوننت دوباره ساخته می‌شود و reference جدید می‌گیرد → باعث رندر فرزند می‌شود.
- **State**: اگر برای `person` از `useState` استفاده کنید، برای هر تغییر کوچک مجبورید `setPerson` صدا بزنید، که خودش یک رندر اضافه می‌آورد.
- **`useMemo`** بهترین راه است چون بدون ایجاد state اضافی یک reference پایدار تولید می‌کند.

---

### نکات کلیدی

1. **`memo` بدون `useMemo` و `useCallback` در صورت استفاده از آبجکت‌ها یا توابع بی‌اثر است** چون reference آن‌ها در هر رندر جدید می‌شود.
2. **`useMemo` برای داده‌ها** است، **`useCallback` برای توابع**.
3. استفاده بی‌رویه از این هوک‌ها می‌تواند کد را پیچیده‌تر کند و بهبود محسوسی ایجاد نکند مگر در کامپوننت‌های سنگین.

---
