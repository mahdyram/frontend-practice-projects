```jsx
const store = {
  state: { cart: [], shop: [] },
};

console.log(store.state);
```

کدی که نوشتی یک آبجکت ساده به نام `store` می‌سازد که شامل یک property به نام `state` است. این `state` خودش یک آبجکت است که دو آرایه‌ی خالی `cart` و `shop` دارد.

وقتی می‌نویسی:

```javascript
console.log(store.state);
```

خروجی در کنسول خواهد بود:

```javascript
{ cart: [], shop: [] }
```

یعنی وضعیت فعلی `state` که هر دو آرایه‌ خالی هستند.

می‌خواهی همین را به یک **Store واقعی با Redux** تبدیل کنیم یا همین ساختار ساده کافی است؟

---

در این نسخه:

```javascript
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },
};

console.log(store.getState());
```

### تغییر اصلی

- متدی به نام `getState` اضافه شده است.
- به جای دسترسی مستقیم به `store.state`، اکنون از متد `store.getState()` استفاده می‌کنی.

### تفاوت با حالت قبل

1. **دسترسی غیرمستقیم به state**

   - قبلاً `console.log(store.state)` به صورت مستقیم مقدار state را برمی‌گرداند.
   - حالا با `getState()` این مقدار را از طریق یک متد دریافت می‌کنی.

2. **مزیت**

   - این روش شبیه معماری Redux است که دسترسی مستقیم به state را محدود می‌کند و از طریق متدها (getterها) آن را مدیریت می‌کند.
   - در آینده می‌توانی منطق اضافه کنی؛ مثلاً قبل از بازگرداندن state یک کپی بدهی تا کسی نتواند مستقیم آن را تغییر دهد.

### خروجی

همچنان خروجی همان است:

```javascript
{ cart: [], shop: [] }
```

آیا می‌خواهی **متد setState** هم اضافه کنیم تا شبیه Redux شود و state را فقط از طریق یک action تغییر دهیم؟

---

در این نسخه:

```javascript
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },

  // setState === dispatch
  setState() {
    this.state.cart.push("apple");
  },
};

store.setState();
console.log(store.getState());
```

### تغییرات نسبت به قبل

1. **متد `setState`** اضافه شده که:

   - به صورت مستقیم درون آن مقدار `cart` تغییر می‌کند و `"apple"` اضافه می‌شود.
   - دیگر نیازی به ارسال مقدار جدید نیست؛ رفتار آن ثابت است.

2. **تشبیه به Redux**

   - در Redux چیزی به نام `dispatch` داریم که یک **action** می‌گیرد و reducer تغییر state را بر اساس آن اعمال می‌کند.
   - در اینجا `setState` بدون ورودی، مثل یک dispatch ثابت عمل می‌کند که همیشه یک Apple اضافه می‌کند.

### خروجی

پس از اجرای `store.setState()`:

```javascript
{ cart: ["apple"], shop: [] }
```

### نکته مهم

هنوز تغییر مستقیم روی state انجام می‌شود (یعنی `this.state.cart.push` مستقیماً آرایه را تغییر می‌دهد).
در Redux واقعی، state **immutable** است و همیشه کپی جدید ساخته می‌شود.

آیا می‌خواهی همین مدل را کمی ارتقا دهیم تا **قابلیت افزودن هر آیتم دلخواه** (نه فقط Apple) داشته باشد؟

---

نسخه ارتقا یافته که می‌توانی هر آیتم دلخواه را اضافه کنی:

```javascript
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },

  // setState حالا یک مقدار دریافت می‌کند
  setState(item) {
    if (typeof item === "string" && item.trim() !== "") {
      this.state.cart.push(item);
    } else {
      console.error("Item باید یک رشته معتبر باشد!");
    }
  },
};

store.setState("apple");
store.setState("banana");

console.log(store.getState());
```

### خروجی

```javascript
{ cart: ["apple", "banana"], shop: [] }
```

آیا می‌خواهی این **push مستقیم** را حذف کنیم و هر بار یک **کپی جدید از state** بسازیم (مثل Redux که immutable است)؟
یا همین تغییر مستقیم بماند و فقط ساختار action/reducer اضافه شود؟

---

عالی! این گام رو «immutable» می‌کنیم: به‌جای `push`، هر بار یک **آرایه و شیء جدید** می‌سازیم و در `state` می‌گذاریم.

```javascript
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },

  // به‌جای تغییر مستقیم، هر بار state جدید می‌سازیم
  addToCart(item) {
    if (typeof item !== "string" || !item.trim()) return;

    const prev = this.state;
    const next = {
      ...prev, // کپی شیء state
      cart: [...prev.cart, item], // کپی آرایه + آیتم جدید
    };

    this.state = next; // جایگزینی با نسخه‌ی جدید
  },
};

store.addToCart("apple");
store.addToCart("banana");
console.log(store.getState());

// تست مرجع‌ها (اختیاری)
const s1 = store.getState();
store.addToCart("orange");
const s2 = store.getState();
console.log(s1 === s2); // false => شیء state عوض شده
console.log(s1.cart === s2.cart); // false => آرایه cart عوض شده
```

نکته‌ها:

- دیگر از `push` استفاده نمی‌کنیم؛ چون mutable است.
- هر بار که تغییری می‌دهیم، **کپی جدید** می‌سازیم (الگوی Redux).
- بیرون از `store` هم نباید `store.state` را دستکاری کنیم؛ فقط از متدها استفاده کن.

اگر این مرحله اوکیه، قدم بعدی رو برمی‌داریم: تعریف یک متد عمومی‌تر شبیه `dispatch(action)` و یک `reducer(state, action)` که همین به‌روزرسانی‌های immutable را انجام دهد.

---

مرحله‌ی بعدی: پیاده‌سازی **dispatch** و **reducer** به سبک ساده.

```javascript
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },

  // dispatch برای ارسال action
  dispatch(action) {
    this.state = this.reducer(this.state, action);
  },

  // reducer وظیفه دارد state جدید بر اساس action بسازد
  reducer(state, action) {
    switch (action.type) {
      case "ADD_TO_CART":
        return {
          ...state,
          cart: [...state.cart, action.payload],
        };
      default:
        return state; // اگر action ناشناخته باشد، بدون تغییر
    }
  },
};

// استفاده
store.dispatch({ type: "ADD_TO_CART", payload: "apple" });
store.dispatch({ type: "ADD_TO_CART", payload: "banana" });

console.log(store.getState());
```

### خروجی

```javascript
{ cart: ["apple", "banana"], shop: [] }
```

آیا می‌خواهی مرحله بعد **کد را به چند فایل مثل Redux واقعی (store.js و reducer.js و actions.js)** تقسیم کنیم؟
یا قبلش یک مرحله‌ی کوچک‌تر برای **ساخت action creator** انجام دهیم؟

---

درست می‌گی، reducer باید چند نوع action را پشتیبانی کند تا بتوانیم هم روی **cart** و هم روی **shop** تغییر اعمال کنیم.

### نسخه به‌روزشده با پشتیبانی از shop

```javascript
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },

  dispatch(action) {
    this.state = this.reducer(this.state, action);
  },

  reducer(state, action) {
    switch (action.type) {
      case "ADD_TO_CART":
        return {
          ...state,
          cart: [...state.cart, action.payload],
        };
      case "ADD_TO_SHOP":
        return {
          ...state,
          shop: [...state.shop, action.payload],
        };
      default:
        return state;
    }
  },
};

// تست
store.dispatch({ type: "ADD_TO_CART", payload: "apple" });
store.dispatch({ type: "ADD_TO_SHOP", payload: "store1" });

console.log(store.getState());
```

### خروجی

```javascript
{ cart: ["apple"], shop: ["store1"] }
```

حالا می‌تونیم **action creator** بسازیم که فقط فانکشن‌هایی هستند که **action object** برمی‌گردانند.

آیا می‌خوای **action creator**‌ها را هم برای cart و هم shop تعریف کنیم؟
یا اول فقط برای cart بسازیم و بعد shop را اضافه کنیم؟

---

### **Action Creator چیست؟**

در Redux یا ساختار مشابه، **action** یک شیء ساده است که مشخص می‌کند چه تغییری باید روی state اعمال شود. مثلاً:

```javascript
{ type: "ADD_TO_CART", payload: "apple" }
```

اما هر بار که بخواهیم یک action بسازیم، نوشتن این شیء به صورت دستی تکراری و پرخطاست.
**Action Creator** یک **تابع** است که این شیء را تولید می‌کند.

### چرا مفید است؟

- جلوی خطاهای تایپی در type را می‌گیرد.
- تولید action را ساده و قابل استفاده مجدد می‌کند.
- می‌توانیم منطق بیشتری (مثل اعتبارسنجی) قبل از ساخت action اضافه کنیم.

### نمونه Action Creator برای Cart

```javascript
// تعریف action creator
function addToCart(item) {
  return {
    type: "ADD_TO_CART",
    payload: item,
  };
}

// استفاده از آن در store
store.dispatch(addToCart("apple"));
store.dispatch(addToCart("banana"));

console.log(store.getState());
```

### مزیت

به‌جای:

```javascript
store.dispatch({ type: "ADD_TO_CART", payload: "apple" });
```

می‌نویسیم:

```javascript
store.dispatch(addToCart("apple"));
```

که تمیزتر و امن‌تر است.

آیا می‌خواهی **constants برای action types** تعریف کنیم (مثل `const ADD_TO_CART = "ADD_TO_CART";`)
تا کد قابل نگهداری‌تر شود و اشتباه تایپی کم شود؟
یا مستقیم برویم سراغ **Action Creator برای shop**؟

---

عالی! حالا می‌خواهیم **نسخه کامل** را بسازیم که هم `cart` و هم `shop` را پشتیبانی کند، با **action creators** و **dispatch** و **reducer**.

```javascript
// Constants برای جلوگیری از اشتباه تایپی
const ADD_TO_CART = "ADD_TO_CART";
const ADD_TO_SHOP = "ADD_TO_SHOP";

// Action creators
function addToCart(item) {
  return { type: ADD_TO_CART, payload: item };
}

function addToShop(shop) {
  return { type: ADD_TO_SHOP, payload: shop };
}

// Store ساده
const store = {
  state: { cart: [], shop: [] },

  getState() {
    return this.state;
  },

  dispatch(action) {
    this.state = this.reducer(this.state, action);
  },

  reducer(state, action) {
    switch (action.type) {
      case ADD_TO_CART:
        return { ...state, cart: [...state.cart, action.payload] };
      case ADD_TO_SHOP:
        return { ...state, shop: [...state.shop, action.payload] };
      default:
        return state;
    }
  },
};

// استفاده
store.dispatch(addToCart("apple"));
store.dispatch(addToCart("banana"));
store.dispatch(addToShop("store1"));
store.dispatch(addToShop("store2"));

console.log(store.getState());
```

### خروجی

```js
{ cart: ["apple", "banana"], shop: ["store1", "store2"] }
```

✅ این نسخه شامل:

1. **Immutable state**
2. **Reducer واحد** که چند action را پشتیبانی می‌کند
3. **Action creators** برای cart و shop
4. **Dispatch** برای اعمال تغییرات

اگر بخوای، مرحله بعد می‌توانیم **ساختار واقعی Redux با فایل‌های جداگانه** (store.js, actions.js, reducer.js) را شبیه‌سازی کنیم تا پروژه قابل نگهداری‌تر شود.

میخوای بریم به اون مرحله؟

---

بله حتما! مرحله بعدی بعد از این ساختار ساده، می‌تونه **استفاده از slice** باشه، مثل کاری که Redux Toolkit انجام می‌دهد.

**Slice چیست؟**

- در واقع یک **بخش از state** است (مثلاً cart یا shop).
- شامل **state اولیه، reducerها و action creators** مرتبط با همان بخش است.
- با slice، دیگر نیازی نیست همه actionها و reducerها را در یک فایل بزرگ مدیریت کنیم.
- Redux Toolkit به صورت خودکار **action creators** را هم از روی reducerها می‌سازد.

مثال ساده:

```javascript
const cartSlice = {
  state: [],
  reducers: {
    add: (state, action) => [...state, action.payload],
    remove: (state, action) => state.filter((item) => item !== action.payload),
  },
};
```

بعدا می‌توانیم این sliceها را **combine** کنیم تا store کامل ساخته شود.

اگر بخوای، می‌توانیم مرحله بعد **cartSlice و shopSlice** را درست کنیم و store را با آنها بسازیم، شبیه Redux Toolkit.

میخوای همین کار را شروع کنیم؟

---

عالی، پس قدم به قدم پیش می‌رویم. 🌟

### **مرحله اول: جدا کردن cart به یک slice ساده**

از نسخه قبلی شروع می‌کنیم که `store` داریم و `cart` و `shop` را با یک reducer مدیریت می‌کنیم.
حالا می‌خواهیم **cartSlice** بسازیم که فقط مسئول `cart` باشد.

#### کد:

```javascript
// cartSlice.js
const ADD_TO_CART = "ADD_TO_CART";

const cartSlice = {
  state: [], // فقط cart
  reducers: {
    add(state, action) {
      return [...state, action.payload]; // immutable update
    },
  },
  actionCreators: {
    addToCart(item) {
      return { type: ADD_TO_CART, payload: item };
    },
  },
};

export default cartSlice;
export { ADD_TO_CART };
```

#### تغییرات نسبت به کد قبلی

1. **state جدا شد**

   - قبلاً `state: { cart: [], shop: [] }` بود، حالا فقط `cart: []`.

2. **reducer داخل slice**

   - یک متد `add` تعریف کردیم که فقط cart را تغییر می‌دهد.

3. **action creator داخل slice**

   - `addToCart` حالا جزو slice است.

4. **immutable update**

   - همچنان از `[...state, item]` استفاده می‌کنیم، پس تغییرات مستقیم روی آرایه اصلی انجام نمی‌شود.

---

تفاوت اصلی بین `add` و `addToCart` در این است که **نقش و سطح آن‌ها متفاوت است**:

### 1️⃣ `add`

- داخل **slice** و در بخش **reducers** تعریف می‌شود.
- وظیفه‌اش **تغییر state** است.
- مثال:

```javascript
add(state, action) {
  return [...state, action.payload];
}
```

- وقتی `add` اجرا می‌شود، فقط state را بروزرسانی می‌کند.
- در Redux Toolkit، این متد خودکار با dispatch و action مرتبط می‌شود.

### 2️⃣ `addToCart`

- داخل **actionCreators** یا خارج از slice تعریف می‌شود.
- وظیفه‌اش فقط **ساخت action object** است، نه تغییر state.
- مثال:

```javascript
addToCart(item) {
  return { type: ADD_TO_CART, payload: item };
}
```

- وقتی `store.dispatch(addToCart("apple"))` اجرا می‌شود، `addToCart` فقط یک action می‌سازد و آن را به store می‌فرستد.
- بعد **reducer** (در اینجا `add`) بر اساس نوع action، state را تغییر می‌دهد.

💡 خلاصه ساده:

- **add:** تغییر state ✅
- **addToCart:** ساخت action برای dispatch ✅

اگر این واضح است، می‌توانیم **قدم بعدی: combine کردن cartSlice و shopSlice در یک store کامل** را شروع کنیم.

---

عالی! پس قدم بعدی: **ساخت store با combine کردن cartSlice و shopSlice**، مرحله به مرحله.

### **مرحله 1: shopSlice ساده**

مشابه cartSlice، shopSlice هم داریم:

```javascript
// shopSlice.js
const ADD_TO_SHOP = "ADD_TO_SHOP";

const shopSlice = {
  state: [], // فقط shop
  reducers: {
    add(state, action) {
      return [...state, action.payload]; // immutable update
    },
  },
  actionCreators: {
    addToShop(shop) {
      return { type: ADD_TO_SHOP, payload: shop };
    },
  },
};

export default shopSlice;
export { ADD_TO_SHOP };
```

### **مرحله 2: combineSlices**

حالا می‌خواهیم یک store بسازیم که **چند slice** را مدیریت کند.
ایده: برای هر slice، state و reducer جداگانه داریم و store آنها را با هم ترکیب می‌کند.

```javascript
// store.js
import cartSlice, { ADD_TO_CART } from "./cartSlice.js";
import shopSlice, { ADD_TO_SHOP } from "./shopSlice.js";

const store = {
  state: {
    cart: cartSlice.state,
    shop: shopSlice.state,
  },

  getState() {
    return this.state;
  },

  dispatch(action) {
    this.state = {
      cart: cartSlice.reducers.add(this.state.cart, action),
      shop: shopSlice.reducers.add(this.state.shop, action),
    };
  },
};

export default store;
```

### **مرحله 3: استفاده از store و action creators**

```javascript
import store from "./store.js";
import { addToCart } from "./cartSlice.js";
import { addToShop } from "./shopSlice.js";

store.dispatch(addToCart("apple"));
store.dispatch(addToCart("banana"));
store.dispatch(addToShop("store1"));

console.log(store.getState());
```

### خروجی

```javascript
{ cart: ["apple", "banana"], shop: ["store1"] }
```

✅ نکات مهم:

1. هر slice فقط state خودش و reducer خودش را دارد.
2. store با combine کردن این sliceها، state کلی را می‌سازد.
3. dispatch برای همه sliceها اجرا می‌شود، و reducer هر slice تصمیم می‌گیرد که آیا action مربوط به خودش است یا نه.

اگر بخوای، **قدم بعد** می‌توانیم **نسخه بهبود یافته dispatch** بسازیم که **هر slice خودش تشخیص دهد action مربوط به خودش است**،
تا store خیلی تمیز و شبیه Redux Toolkit شود.

---

عالی! 🌟 حالا می‌خوایم **dispatch هوشمند** بسازیم، تا هر slice خودش بررسی کند آیا action مربوط به خودش است یا نه. این دقیقا همان چیزی است که در Redux Toolkit با `createSlice` اتفاق می‌افتد.

### **مرحله 1: اصلاح sliceها**

برای هر slice، reducer بررسی می‌کند که action type مربوط به خودش باشد:

```javascript
// cartSlice.js
const ADD_TO_CART = "ADD_TO_CART";

const cartSlice = {
  state: [],
  reducers: {
    add(state, action) {
      if (action.type !== ADD_TO_CART) return state; // فقط action مخصوص خودش را تغییر می‌دهد
      return [...state, action.payload];
    },
  },
  actionCreators: {
    addToCart(item) {
      return { type: ADD_TO_CART, payload: item };
    },
  },
};

export default cartSlice;
export { ADD_TO_CART };
```

```javascript
// shopSlice.js
const ADD_TO_SHOP = "ADD_TO_SHOP";

const shopSlice = {
  state: [],
  reducers: {
    add(state, action) {
      if (action.type !== ADD_TO_SHOP) return state; // فقط action خودش
      return [...state, action.payload];
    },
  },
  actionCreators: {
    addToShop(shop) {
      return { type: ADD_TO_SHOP, payload: shop };
    },
  },
};

export default shopSlice;
export { ADD_TO_SHOP };
```

### **مرحله 2: اصلاح store**

حالا store خیلی تمیزتر می‌شود؛ هر slice خودش تصمیم می‌گیرد که action را پردازش کند یا نه:

```javascript
// store.js
import cartSlice from "./cartSlice.js";
import shopSlice from "./shopSlice.js";

const store = {
  state: {
    cart: cartSlice.state,
    shop: shopSlice.state,
  },

  getState() {
    return this.state;
  },

  dispatch(action) {
    this.state = {
      cart: cartSlice.reducers.add(this.state.cart, action),
      shop: shopSlice.reducers.add(this.state.shop, action),
    };
  },
};

export default store;
```

### **مرحله 3: استفاده**

```javascript
import store from "./store.js";
import { addToCart } from "./cartSlice.js";
import { addToShop } from "./shopSlice.js";

store.dispatch(addToCart("apple"));
store.dispatch(addToCart("banana"));
store.dispatch(addToShop("store1"));
store.dispatch(addToShop("store2"));

console.log(store.getState());
```

### خروجی

```javascript
{ cart: ["apple", "banana"], shop: ["store1", "store2"] }
```

✅ مزیت این روش:

1. **dispatch هوشمند شد**: هر slice خودش action مناسب را پردازش می‌کند.
2. **store تمیز و مقیاس‌پذیر**: اضافه کردن slice جدید ساده است، کافیست slice جدید را به state و dispatch اضافه کنیم.
3. **قابلیت گسترش**: حالا می‌توانیم راحت multi-action و featureهای پیچیده اضافه کنیم.

اگر بخوای، مرحله بعد می‌توانیم **store شبیه Redux Toolkit با createSlice واقعی** بسازیم که **دیگر نیازی به چک کردن type در reducerها هم نباشد** و کد خیلی کوتاه‌تر شود.

---

دقیقا، مهدی! 😄

در ظاهر، **store هنوز همان store قبلی است** و تغییری در نحوه‌ی استفاده ندارد:

```javascript
store.dispatch(addToCart("apple"));
store.dispatch(addToShop("store1"));
console.log(store.getState());
```

همان خروجی قبل را می‌دهد:

```javascript
{ cart: ["apple"], shop: ["store1"] }
```

✅ فرق اصلی در این مرحله **داخلی sliceهاست**:

1. قبلاً **هر slice فرض می‌کرد همه actionها برایش هستند** و reducer بدون چک type اجرا می‌شد.
2. الان **هر reducer داخل slice خودش بررسی می‌کند که آیا action مخصوص خودش است یا نه** (`if (action.type !== ADD_TO_CART) return state`).
3. این باعث می‌شود که **dispatch امن‌تر و scalable شود**، مخصوصا وقتی sliceهای بیشتری اضافه کنیم.

پس در عمل هنوز ظاهر store یکسان است، اما **ساختار داخلی آماده مرحله بعدی و افزایش sliceها و actions پیچیده‌تر** شده است.

اگر بخوای، مرحله بعد می‌توانیم **شبیه Redux Toolkit با createSlice واقعی** بسازیم، که دیگر **این ifها لازم نیست** و کد خیلی تمیزتر و کوتاه‌تر می‌شود.

---

---

عالی! 🌟 پس قدم بعد: شبیه‌سازی **Redux Toolkit با `createSlice`**.

ایده اصلی:

- در Redux Toolkit، وقتی `createSlice` می‌سازیم، **state، reducerها و action creators** همه با هم تعریف می‌شوند.
- دیگر نیازی نیست در reducerها `if (action.type === ...)` بنویسیم، چون **Toolkit خودش actionها را با reducer مرتبط می‌کند**.

---

### **مرحله 1: شبیه‌سازی createSlice برای cart**

```javascript
// createSlice شبیه‌سازی
function createSlice({ name, initialState, reducers }) {
  const actionCreators = {};

  // ساخت action creator برای هر reducer
  for (const key in reducers) {
    const type = `${name}/${key}`;
    actionCreators[key] = (payload) => ({ type, payload });
  }

  // reducer اصلی
  const reducer = (state = initialState, action) => {
    const actionType = action.type;
    const slicePrefix = `${name}/`;
    if (actionType.startsWith(slicePrefix)) {
      const key = actionType.slice(slicePrefix.length);
      return reducers[key](state, action);
    }
    return state;
  };

  return { reducer, actionCreators, name, initialState };
}
```

---

### **مرحله 2: تعریف cartSlice با createSlice**

```javascript
const cartSlice = createSlice({
  name: "cart",
  initialState: [],
  reducers: {
    add: (state, action) => [...state, action.payload],
    remove: (state, action) => state.filter((item) => item !== action.payload),
  },
});

const { add: addToCart, remove: removeFromCart } = cartSlice.actionCreators;
```

- `cartSlice.reducer` را برای store استفاده می‌کنیم.
- `addToCart("apple")` یک action می‌سازد که reducer خودش آن را پردازش می‌کند.

---

### **مرحله 3: تعریف shopSlice به همان سبک**

```javascript
const shopSlice = createSlice({
  name: "shop",
  initialState: [],
  reducers: {
    add: (state, action) => [...state, action.payload],
  },
});

const { add: addToShop } = shopSlice.actionCreators;
```

---

### **مرحله 4: ساخت store با combineSlices**

```javascript
const store = {
  state: {
    cart: cartSlice.initialState,
    shop: shopSlice.initialState,
  },

  getState() {
    return this.state;
  },

  dispatch(action) {
    this.state = {
      cart: cartSlice.reducer(this.state.cart, action),
      shop: shopSlice.reducer(this.state.shop, action),
    };
  },
};

// استفاده
store.dispatch(addToCart("apple"));
store.dispatch(addToCart("banana"));
store.dispatch(addToShop("store1"));

console.log(store.getState());
```

### خروجی

```javascript
{ cart: ["apple", "banana"], shop: ["store1"] }
```

---

✅ مزیت‌های این روش:

1. **دیگر نیاز به if در reducerها نیست**، action خودش با reducer مرتبط است.
2. **action creatorها به صورت خودکار ساخته می‌شوند**.
3. **قابلیت افزودن sliceهای جدید بسیار ساده** و store تمیز باقی می‌ماند.

---

اگر بخوای، قدم بعد می‌توانیم این را یک مرحله جلوتر ببریم و **چند slice را با یک combine واقعی شبیه `configureStore` ترکیب کنیم** تا دقیقا مثل Redux Toolkit شود.
