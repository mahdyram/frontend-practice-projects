رندر سمت کلاینت ( Client Side Rendering – CSR )
رندر سمت سرور ( Server Side Rendering – SSR )

بذار ساده و مقایسه‌ای توضیح بدم 👇

---

### 🖥️ **Client Side Rendering (CSR)**

- **چی هست؟**
  توی این روش، مرورگر (کلاینت) یه فایل HTML خیلی ساده (تقریباً خالی) از سرور می‌گیره، بعد جاوااسکریپت (مثلاً React, Vue, Angular) شروع می‌کنه و محتوا رو می‌سازه.
- **مراحل:**

  1. مرورگر درخواست رو می‌فرسته.
  2. سرور فقط یه صفحه HTML خام + فایل‌های JS/CSS رو می‌فرسته.
  3. جاوااسکریپت روی مرورگر اجرا میشه و محتوا رندر میشه.

- **مزایا:**

  - تجربه تعاملی و داینامیک خیلی خوب.
  - بارگذاری بعدی صفحات سریع (Single Page Application).

- **معایب:**

  - اولین بارگذاری (First Load) ممکنه کند باشه، چون مرورگر باید همه JS رو دانلود و اجرا کنه.
  - سئو (SEO) ضعیف‌تره، چون محتوای اولیه خالیه و موتورهای جستجو باید صبر کنن.

---

### 🌐 **Server Side Rendering (SSR)**

- **چی هست؟**
  توی این روش، رندر شدن محتوا روی **سرور** انجام میشه. یعنی سرور همون HTML کامل و آماده رو می‌سازه و به مرورگر می‌فرسته.
- **مراحل:**

  1. مرورگر درخواست رو می‌فرسته.
  2. سرور داده‌ها رو می‌گیره، رندر می‌کنه و یه HTML کامل تحویل میده.
  3. مرورگر HTML رو سریع نشون میده، بعداً جاوااسکریپت فعال میشه (Hydration).

- **مزایا:**

  - بارگذاری اولیه خیلی سریع‌تر.
  - سئو خیلی بهتر (چون HTML کامل از همون اول وجود داره).

- **معایب:**

  - بار روی سرور بیشتره.
  - ممکنه در تعاملات بعدی کمی کندتر باشه (بسته به پیاده‌سازی).

---

### 🆚 مقایسه سریع:

| ویژگی                   | CSR             | SSR        |
| ----------------------- | --------------- | ---------- |
| **محل رندر**            | مرورگر (کلاینت) | سرور       |
| **سرعت بارگذاری اولیه** | کندتر           | سریع‌تر    |
| **سئو (SEO)**           | ضعیف‌تر         | خیلی خوب   |
| **بار روی سرور**        | کمتر            | بیشتر      |
| **تعاملات بعدی**        | سریع‌تر         | گاهی کندتر |

---

🔑 **جمع‌بندی:**

- اگه پروژه بیشتر شبیه **اپلیکیشن** باشه (داشبورد، پنل کاربری، اپ SPA) → **CSR**
- اگه پروژه بیشتر شبیه **وبسایت محتوایی یا فروشگاهی** باشه (نیاز به سئو و لود سریع) → **SSR**

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

### 🔹 در **CSR (Client Side Rendering)**

- وقتی برای اولین بار صفحه لود میشه، مرورگر همه‌ی فایل‌های جاوااسکریپت رو دانلود می‌کنه.
- بعد از اون، **ناوبری (رفتن به صفحه‌ی بعدی)** یا تغییر محتوا خیلی سریع میشه چون همه‌چیز **روی مرورگر** هست.
- مرورگر فقط داده‌ی خام (مثلاً JSON از API) می‌گیره و خودش با JS محتوا رو می‌سازه → پس تعاملات بعدی خیلی سریع انجام میشن.

📌 مثال:
وقتی داخل یک پنل کاربری (SPA) از یک تب به تب دیگه می‌ری، صفحه کامل رفرش نمیشه؛ فقط داده جدید میاد و React/Vue آپدیت می‌کنه.

---

### 🔹 در **SSR (Server Side Rendering)**

- هر بار که کاربر به صفحه‌ی جدید میره یا چیزی عوض میشه، مرورگر باید دوباره یه درخواست به **سرور** بفرسته.
- سرور دوباره باید HTML کامل رو رندر کنه و بفرسته.
- این یعنی:

  - تعاملات بعدی **نیازمند رفت و برگشت به سرور** هستن.
  - سرعت به اندازه CSR نیست (به‌ویژه وقتی سرور دور باشه یا پردازش سنگین باشه).

📌 مثال:
توی یک سایت فروشگاهی SSR وقتی از صفحه محصول به صفحه دسته‌بندی میری، سرور باید دوباره کل HTML رو بسازه و بفرسته.

---

### ⚡ نتیجه:

- **CSR →** تعاملات بعدی سریع‌تر چون فقط داده جابه‌جا میشه.
- **SSR →** تعاملات بعدی کندتر چون هر بار سرور باید HTML کامل تولید کنه.

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

ینی دیگه تو ssr جابجایی بین صفحات با reloading همراهه ؟

آها دقیقا رسیدی به نکته‌ی کلیدی 👌

جواب اینه: **بستگی به فریم‌ورک و پیاده‌سازی داره.**

---

### 🔹 SSR کلاسیک (قدیمی)

- بله ✅
- وقتی کاربر از یک صفحه به صفحه دیگه میره، مرورگر باید دوباره کل صفحه رو **reload** کنه.
- چون هر صفحه‌ی HTML از صفر توسط سرور ساخته و ارسال میشه.
- این حالت بیشتر توی وب‌سایت‌های قدیمی (PHP, ASP.NET, JSP) بود.

---

### 🔹 SSR مدرن (مثل Next.js, Nuxt.js)

- نه ❌
- اینا ترکیبی از SSR + CSR هستن.
- یعنی:

  - بار اول، سرور HTML کامل رو میده (سریع + مناسب سئو).
  - بعدش، جاوااسکریپت روی مرورگر "hydrate" میشه تا بخش‌های Client Component تعاملی فعال شوند و مثل CSR رفتار می‌کنه.
  - پس جابجایی بین صفحات معمولاً **بدون reload کامل** انجام میشه (SPA-feeling).

- به این حالت بعضی وقتا میگن **SSR + Hydration** یا **Universal Rendering**.

---

### 📝 خلاصه:

- **SSR کلاسیک →** جابجایی بین صفحات = reload کامل.
- **SSR مدرن (مثلاً Next.js) →** جابجایی بین صفحات = بدون reload، مثل CSR.

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

خیلی خوبه که روی اون خط دقیق شدی، چون **Hydration** یکی از مهم‌ترین مفاهیم SSR مدرن (مثل Next.js) هست 🌱

---

### 🔹 ماجرا از کجا شروع میشه؟

1. وقتی از SSR استفاده می‌کنی، **سرور** یه HTML کامل می‌سازه و به مرورگر میده.
   → این باعث میشه کاربر **خیلی سریع** یه صفحه آماده ببینه (و سئو هم خوبه).
2. ولی اون HTML فقط یه متن و ساختار استاتیکه؛ هیچ تعامل (کلیک، فرم، دکمه، state) روش کار نمی‌کنه چون هنوز جاوااسکریپت وصل نشده.

---

### 🔹 Hydration یعنی چی؟

- Hydration فرآیندیه که توی اون **جاوااسکریپت سمت کلاینت** میاد و روی همین HTMLی که سرور داده، **ایونت‌ها و رفتارها** رو وصل می‌کنه.
- به زبان ساده:

  - سرور "اسکلت" رو ساخته.
  - مرورگر (کلاینت) میاد "روح" رو توش می‌دَمه 😅 و همه چیز زنده و تعاملی میشه.

---

### 🔹 مثال خیلی ساده

فرض کن توی SSR سرور این HTML رو ساخته و فرستاده:

```html
<button>Click me</button>
```

کاربر دکمه رو می‌بینه، اما اگه روش کلیک کنه، هیچ اتفاقی نمیفته.
بعد که فایل جاوااسکریپت دانلود و اجرا میشه، React یا Vue میاد و میگه:

> "آها! این همون `<button>` منه. من باید بهش onClick وصل کنم."

از اون لحظه به بعد، دکمه واقعاً کار می‌کنه.
این فرایند وصل کردن **JS logic به HTML موجود** همون **hydration** هست.

---

### 🔹 چرا بهش میگن Hydration؟

- چون سرور یه صفحه‌ی "خشک" و بدون تعامل میده.
- مرورگر با جاوااسکریپت اونو "خیس" و زنده می‌کنه → به همین خاطر بهش میگن **Hydrate**.

---

### 📝 خلاصه:

- **SSR** → HTML آماده از سرور میاد (سریع + برای سئو خوب).
- **Hydration** → مرورگر جاوااسکریپت رو روی اون HTML سوار می‌کنه و رفتارها رو فعال می‌کنه.
- بعد از Hydration، دیگه تعاملات بعدی مثل CSR سریع انجام میشن (بدون reload).

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

عالیه 👌 حالا که مطمئن شدیم توی **Next.js 15 + React 19** همه‌چی روی **RSC (React Server Components)** می‌چرخه، بذار کامل و مرحله‌به‌مرحله توضیحش بدم.

---

## 🔹 React Server Components (RSC) چی هستن؟

RSC یک قابلیت جدیده که توسط تیم React معرفی شد (و Next.js اولین فریم‌ورکی بود که پیاده‌سازی پایدارش رو آورد).
ایده‌اش اینه که:

> **بخشی از کامپوننت‌های React روی سرور رندر بشن، نه روی مرورگر.**

---

## 🔹 تفاوت اصلی با React سنتی

- توی React معمولی (و Next.js قدیمی):
  همه‌ی کامپوننت‌ها در نهایت روی **کلاینت (مرورگر)** اجرا می‌شدن → یعنی همون HTML + کل باندل جاوااسکریپت.
  ✖️ مشکل: حجم JS زیاد، سرعت لود پایین، مصرف بیشتر RAM/CPU روی کاربر.

- توی React Server Components:

  - بخش‌هایی از UI (مثل لیست محصولات، متن، داده‌ها) **روی سرور** ساخته میشه.
  - خروجی HTML آماده برای مرورگر ارسال میشه.
  - مرورگر لازم نیست برای اون قسمت جاوااسکریپت دانلود کنه.
    ✔️ نتیجه: حجم JS کمتر، سرعت بیشتر.

---

## 🔹 انواع کامپوننت در RSC

1. **Server Component (پیش‌فرض)**

   - بدون `use client`
   - اجرا فقط روی سرور
   - می‌تونه مستقیم به DB وصل بشه، فایل‌سیستم بخونه، API صدا بزنه
   - نمی‌تونه state یا event handler داشته باشه

2. **Client Component**

   - با نوشتن `"use client"` بالای فایل
   - اجرا روی مرورگر
   - می‌تونه از state (`useState`)، اثرها (`useEffect`) و event handlerها (`onClick`, `onChange`) استفاده کنه
   - فقط برای بخش‌های تعاملی استفاده میشه

---

## 🔹 فلو اجرای RSC در Next.js

1. کاربر درخواست صفحه میده → سرور Next.js کامپوننت‌های **Server** رو اجرا می‌کنه.
2. خروجی HTML آماده + meta data JSON مخصوص React به مرورگر میره.
3. مرورگر HTML رو نشون میده.
4. فقط بخش‌هایی که **Client Component** هستن، جاوااسکریپتشون دانلود و **hydrate** میشه.

---

## 🔹 مثال واقعی

```jsx
// app/products/page.js
import AddToCartButton from "@/components/AddToCartButton";

export default async function ProductsPage() {
  const res = await fetch("https://dummyjson.com/products", {
    cache: "no-store",
  });
  const products = await res.json();

  return (
    <ul>
      {products.products.map((p) => (
        <li key={p.id}>
          {p.title}
          {/* فقط این بخش کلاینتیه */}
          <AddToCartButton productId={p.id} />
        </li>
      ))}
    </ul>
  );
}
```

```jsx
// components/AddToCartButton.js
"use client";

export default function AddToCartButton({ productId }) {
  return (
    <button onClick={() => alert(`Added ${productId} to cart!`)}>
      Add to Cart
    </button>
  );
}
```

- لیست محصولات (`<li>`) → سرور رندر می‌کنه.
- دکمه → کلاینت hydrate می‌کنه.

---

## 🔹 مزایا

1. 🚀 **Performance بهتر**: حجم JS سمت کاربر خیلی کم میشه.
2. 🔒 **امنیت بیشتر**: چون کوئری DB و API key روی سرور می‌مونه.
3. 🖥 **SEO بهتر**: محتوای کامل HTML از سرور ارسال میشه.
4. 🧩 **ترکیب‌پذیری**: می‌تونی بخش‌هایی رو سروری نگه داری و فقط تعاملات رو کلاینتی کنی.

---

## 🔹 محدودیت‌ها

- نمی‌تونی توی Server Component از:

  - `useState`, `useEffect`, event handlerها
  - APIهای مرورگر (مثل `window`, `document`)
    استفاده کنی.

- هر چیزی که تعاملی باشه، باید حتماً **Client Component** باشه.

---

حتماً، یه متن ساده برای توضیح فلو React Server Components به شکل خطی میشه اینطوری:

وقتی کاربر یک صفحه در **Next.js 15 + React 19** درخواست می‌ده، مراحل به ترتیب زیر طی می‌شه:

1️⃣ **درخواست به سرور**: مرورگر درخواست URL صفحه رو می‌فرسته.
2️⃣ **رندر سروری (Server Components)**: سرور کامپوننت‌های سروری صفحه رو اجرا می‌کنه، داده‌ها رو می‌گیره و HTML آماده می‌سازه.
3️⃣ **ارسال HTML و داده‌ها به مرورگر**: مرورگر HTML صفحه و metadata مخصوص React رو دریافت می‌کنه.
4️⃣ **نمایش محتوا در مرورگر**: مرورگر بدون نیاز به جاوااسکریپت بخش سروری صفحه رو نشون می‌ده.
5️⃣ **Hydration بخش کلاینتی**: فقط کامپوننت‌هایی که `"use client"` دارن، جاوااسکریپتشون دانلود و hydrate می‌شه تا تعامل کاربر مثل `onClick`، state و effectها فعال بشه.
6️⃣ **تعامل کاربر**: حالا دکمه‌ها، فرم‌ها و بخش‌های تعاملی بدون مشکل کار می‌کنن، در حالی که بقیه صفحه هنوز فقط HTML سبک سروریه و حجم JS کم شده.

---

## 🔹 جمع‌بندی

- در **Next.js 15 + React 19**:

  - پیش‌فرض = RSC (Server Components)
  - Client Components فقط در صورت نیاز (`"use client"`)

- تفکر جدید:

  > "اول همه‌چی سروریه، مگر اینکه واقعاً نیاز به تعامل کاربر داشته باشه."

#### React Server Components (RSC) – فلو ساده

1️⃣ مرورگر درخواست صفحه می‌ده.
2️⃣ سرور کامپوننت‌های سروری رو اجرا و HTML آماده می‌سازه.
3️⃣ HTML و داده‌ها به مرورگر می‌ره و نمایش داده می‌شه.
4️⃣ فقط کامپوننت‌های `"use client"` دانلود و hydrate می‌شن تا تعامل کاربر فعال بشه.
5️⃣ نتیجه: حجم JS کمتر، سرعت لود بالاتر، تعامل فقط روی بخش‌های کلاینتی.

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

دقیقاً، درست متوجه شدی ✅

- **RSC (React Server Components)** یک **روش / متد رندر** در React هست، **نه یک جایگزین مستقیم SSR یا CSR**.
- ایده‌ش اینه که:

  - بخش‌هایی از UI که **فقط نمایش داده میشن و نیاز به تعامل ندارن** روی سرور رندر بشن → **HTML آماده به مرورگر میره**
  - بخش‌های تعاملی روی **کلاینت Hydrate** میشن

- بنابراین RSC در واقع یه **استراتژی رندر هیبریدی** هست که **مزایای SSR و CSR** رو با هم ترکیب می‌کنه:

  - لود اولیه سریع (مثل SSR/SSG)
  - حجم JS کم سمت کلاینت (برخلاف SSR کلاسیک)
  - تعاملات سریع و بدون reload کامل (مثل CSR)

---

💡 خلاصه کوتاه:

> **RSC = یک روش رندر ترکیبی برای React که بخش‌های بدون تعامل روی سرور و بخش‌های تعاملی روی کلاینت اجرا میشن.**

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

حتماً! بیایم یک **خلاصهٔ خیلی شفاف و جمع‌وجور** از تفاوت‌ها بین **Server Component (RSC) vs SSR** و **Client Component (RSC) vs CSR** تو **Next.js 15 با React 19** داشته باشیم:

---

## 1️⃣ سنتی Server Component (RSC) vs SSR

| ویژگی         | Server Component (RSC)                      | SSR سنتی (getServerSideProps / pages/)                     |
| ------------- | ------------------------------------------- | ---------------------------------------------------------- |
| محل رندر      | سرور (کامپوننت به کامپوننت)                 | سرور (کل صفحه)                                             |
| HTML اولیه    | تولید HTML فقط برای اون کامپوننت            | HTML کامل صفحه ساخته میشه                                  |
| state / event | نداره، فقط HTML و داده                      | می‌تونه state و event داشته باشه ولی بعد Hydrate فعال میشه |
| SEO           | عالی برای محتوای استاتیک                    | عالی، چون HTML اولیه کامل                                  |
| هدف           | بهینه‌سازی ترکیب Server + Client Components | رندر کامل صفحه روی سرور                                    |

**جمع‌بندی:**

- RSC = رندر هر کامپوننت روی سرور، lightweight و بدون تعامل
- SSR سنتی = رندر کل صفحه روی سرور، تعامل بعد از Hydrate

---

## 2️⃣ Client Component (RSC) vs CSR

| ویژگی            | Client Component (RSC)               | CSR خالص                             |
| ---------------- | ------------------------------------ | ------------------------------------ |
| محل رندر         | کلاینت بعد از Hydrate                | کلاینت از ابتدا                      |
| HTML اولیه       | از سرور میاد (Server Component والد) | تقریباً خالی / Skeleton              |
| state / event    | فعال بعد Hydrate                     | همون ابتدا فعال                      |
| SEO              | خوب (HTML اولیه آماده از سرور)       | ضعیف (HTML اولیه نیست)               |
| سرعت نمایش اولیه | سریع‌تر                              | کندتر (JS دانلود میشه و render میشه) |

**جمع‌بندی:**

- Client Component + RSC = تعامل بعد از Hydrate، HTML اولیه از سرور آماده است → SEO و سرعت بهتر
- CSR = همه چیز روی مرورگر ساخته میشه، HTML اولیه کمینه → SEO ضعیف

---

💡 نکته کلیدی:

- **Server Component ≠ SSR سنتی**، ولی RSC می‌تونه جزئی از یک SSR کامل باشه.
- **Client Component ≠ CSR خالص**، ولی اگر از Server Component والد HTML بگیری، سرعت و SEO بهتر میشه.

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

آره، این دقیقاً نکتهٔ کلیدیه. بیایم با دقت بررسی کنیم که چرا **RSC روی هر کامپوننت** هست ولی **SSR سنتی کل صفحه** رو رندر می‌کنه و این فرق چه تأثیری داره:

---

## 1️⃣ SSR سنتی (کل صفحه)

- **چی کار می‌کنه:**

  - سرور **تمام HTML صفحه** رو برای هر درخواست می‌سازه، شامل همه کامپوننت‌ها.
  - بعد مرورگر **Hydrate** می‌کنه تا state و event فعال بشه.

- **مزایا:**

  - SEO عالی، چون HTML اولیه کامل صفحه آماده است
  - ساده برای پروژه‌های قدیمی (`pages/`)

- **معایب:**

  - اگر فقط یک بخش کوچیک صفحه تغییر کنه، باید کل صفحه دوباره روی سرور رندر بشه
  - بار سرور بیشتره چون کل صفحه باید رندر بشه حتی برای تغییرات جزئی

---

## 2️⃣ RSC (Server Component)

- **چی کار می‌کنه:**

  - سرور **هر کامپوننت را جداگانه** رندر می‌کنه و فقط HTML و داده اون بخش رو می‌فرسته
  - هر کامپوننت می‌تونه مستقل از بقیه async باشه و داده fetch کنه

- **مزایا:**

  - **lightweight و بهینه:** فقط بخش‌هایی که لازم هست رندر می‌شن
  - تعامل و state در Client Component جداگانه میشه (نیازی نیست کل صفحه Hydrate بشه)
  - ترکیب Server + Client Components خیلی ساده‌تر و سریع‌تر میشه

- **معایب:**

  - فقط کامپوننت‌هایی که `'use client'` ندارن، بدون تعامل هستن
  - اگر صفحه کاملاً dynamic باشه، هنوز نیاز به Client Component داری

---

## 🔹 جمع‌بندی فرق «هر کامپوننت» vs «کل صفحه»

| ویژگی      | SSR سنتی                                          | RSC (Server Component)                         |
| ---------- | ------------------------------------------------- | ---------------------------------------------- |
| سطح رندر   | کل صفحه                                           | هر کامپوننت جداگانه                            |
| HTML اولیه | کامل برای کل صفحه                                 | فقط HTML هر کامپوننت                           |
| عملکرد     | بار سرور بیشتر، تغییرات جزئی نیاز به رندر کل صفحه | بهینه، فقط بخش‌های نیازمند رندر سرور رندر میشن |
| SEO        | عالی                                              | عالی برای بخش‌های استاتیک                      |
| تعامل      | بعد از Hydrate برای کل صفحه                       | بخش client جداگانه Hydrate میشه                |

---

💡 نکته ساده:

- **SSR سنتی:** همه چیز با هم، heavy و کل صفحه درگیر
- **RSC:** modular، lightweight، فقط بخش‌های لازم رندر میشن و بخش تعاملی جداست

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

عالی، الان می‌رسیم به **Static Site Generation (SSG)** 🌐

---

## 🔹 چی هست SSG در Next.js 15؟ 🌐

- **SSG (Static Site Generation)** یعنی ساخت صفحات **استاتیک** در زمان **build**.
- سرور یا ابزار ساخت سایت، تمام HTML صفحات را **یک‌بار قبل از انتشار** می‌سازد و روی CDN یا سرور ذخیره می‌کند.
- وقتی کاربر صفحه را باز می‌کند، مستقیم **HTML آماده** دریافت می‌شود و نیازی به رندر سمت سرور یا کلاینت ندارد.

---

## 🔹 ویژگی‌ها

1. **بارگذاری بسیار سریع**

   - HTML از قبل آماده‌ست و فقط دانلود می‌شود.

2. **سئو عالی**

   - محتوای صفحات کاملاً موجود است و موتورهای جستجو راحت index می‌کنند.

3. **کمترین فشار روی سرور**

   - سرور فقط فایل استاتیک می‌دهد، پردازش اضافی لازم نیست.

4. **نیاز کمتر به جاوااسکریپت اولیه**

   - بخش زیادی از سایت بدون JS کار می‌کند.

---

## 🔹 تفاوت SSG با SSR و CSR (در Next.js 15 + React 19)

| ویژگی          | CSR                 | SSR                   | SSG (Static)                   |
| -------------- | ------------------- | --------------------- | ------------------------------ |
| محل رندر       | کلاینت              | سرور                  | **قبل از انتشار (Build Time)** |
| زمان رندر      | هنگام بارگذاری صفحه | هنگام درخواست کاربر   | قبل از درخواست کاربر           |
| سرعت لود اولیه | کندتر               | سریع                  | **خیلی سریع**                  |
| سئو            | ضعیف                | خوب                   | **عالی**                       |
| تعامل بعدی     | سریع                | کندتر (در SSR کلاسیک) | سریع (اگر با JS تعاملی باشه)   |

---

## 🔹 مثال SSG با App Router

> مسیر فایل: `app/products/page.js`

```jsx
// app/products/page.js

export const revalidate = 0; // 0 یعنی فقط یکبار موقع build (SSG) یا میتونی revalidate زمانبندی کنی

export default async function ProductsPage() {
  const res = await fetch("https://dummyjson.com/products", {
    cache: "force-cache", // SSG → کش میشه و فقط موقع build fetch اجرا میشه
  });
  const products = await res.json();

  return (
    <ul>
      {products.products.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

- هنگام **build**، HTML صفحه با داده‌های `products` ساخته می‌شود.
- وقتی کاربر سایت را باز می‌کند، مستقیم **HTML آماده** دریافت می‌کند.
- اگر بخواهی بخش تعاملی (مثل دکمه اضافه کردن به سبد) داشته باشی، همانند RSC می‌توانی آن بخش را به **Client Component** منتقل کنی.

---

## 🔹 کی از SSG استفاده کنیم؟

- سایت‌های **محتوایی و بلاگ**
- **صفحات فروشگاهی با محصولات کم تغییر**
- سایت‌هایی که **بار سرور کم و سرعت لود بالا** می‌خواهند

---

💡 نکته: در **Next.js 15 + React 19**، SSG با App Router به کمک **Server Components + fetch با cache مناسب** انجام می‌شود و دیگر از `getStaticProps` استفاده نمی‌کنیم.

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

عالی! اینجا یه **مثال عملی و کامل** آماده کردم که هم SSG باشه، هم Client Component برای تعامل، و هم نکات CSR و SSR و SSG به‌طور ساده پوشش داده شده باشه.

---

## 🔹 مثال عملی: صفحه محصولات با SSG + Client Component

> مسیر فایل: `app/products/page.js`

```jsx
import AddToCartButton from "@/components/AddToCartButton";

// SSG → fetch با cache استاتیک
export const revalidate = 0; // فقط هنگام build اجرا میشه

export default async function ProductsPage() {
  // Server Component → اجرا روی سرور
  const res = await fetch("https://dummyjson.com/products", {
    cache: "force-cache", // SSG → داده‌ها کش میشن
  });
  const products = await res.json();

  return (
    <ul>
      {products.products.map((p) => (
        <li key={p.id}>
          {p.title}
          {/* بخش تعاملی روی کلاینت */}
          <AddToCartButton productId={p.id} />
        </li>
      ))}
    </ul>
  );
}
```

---

### 🔹 Client Component

> مسیر فایل: `components/AddToCartButton.js`

```jsx
"use client";

export default function AddToCartButton({ productId }) {
  return (
    <button
      onClick={() => alert(`Added product ${productId} to cart!`)}
      style={{ marginLeft: "10px", padding: "4px 8px" }}
    >
      Add to Cart
    </button>
  );
}
```

---

## 🔹 توضیح ساده:

1. **SSG**:

   - داده‌ها هنگام build از API گرفته میشن و HTML صفحات ساخته میشه.
   - وقتی کاربر صفحه رو باز می‌کنه، مستقیم HTML آماده دریافت می‌کنه.

2. **Client Component**:

   - دکمه `AddToCartButton` روی مرورگر hydrate میشه تا event handler (`onClick`) کار کنه.
   - فقط جاوااسکریپت لازم برای دکمه دانلود میشه → حجم JS کمتر نسبت به کل صفحه.

3. **CSR / SSR / SSG تفاوت‌ها**:

| ویژگی             | CSR                    | SSR                      | SSG + Client Component        |
| ----------------- | ---------------------- | ------------------------ | ----------------------------- |
| محل رندر HTML     | کلاینت                 | سرور                     | Server Component (HTML آماده) |
| زمان رندر         | هنگام بارگذاری صفحه    | هنگام درخواست کاربر      | قبل از انتشار (Build Time)    |
| تعامل بعدی        | کلاینت (state + event) | کلاینت (Hydrate کل صفحه) | کلاینت فقط بخش تعاملی (دکمه)  |
| حجم JS سمت کلاینت | زیاد                   | متوسط                    | کم (فقط بخش کلاینتی)          |
| سرعت لود اولیه    | کند                    | سریع                     | خیلی سریع                     |
| سئو               | ضعیف                   | خوب                      | عالی                          |

---

💡 نکات:

- **Server Component** → لیست محصولات و HTML استاتیک.
- **Client Component** → دکمه تعاملی.
- می‌تونی هر بخش تعاملی دیگه مثل فرم، فیلتر، یا سبد خرید رو هم همین‌طور Client Component بسازی.

<!-- -------------------------------------------- -->
<hr style="height:5px; background-color:red" />

💡 جمع‌بندی کوتاه :

- **CSR:** همه چیز روی کلاینت، تعامل سریع، بار اولیه JS سنگین، SEO ضعیف.
- **SSR کلاسیک:** HTML آماده از سرور، تعامل کند، reload بین صفحات.
- **SSR مدرن (Next.js):** HTML آماده + Hydration روی Client Component → تعامل مثل SPA.
- **RSC:** بخش بدون تعامل روی سرور، بخش تعاملی روی کلاینت، JS کم و SEO عالی.
- **SSG:** ساخت صفحات استاتیک هنگام build، HTML آماده، حجم JS کم، تعامل با Client Component‌ها.
